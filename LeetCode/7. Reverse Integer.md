There are two implementations for this:
- Using the mathematical method.
- Using Elixir's inbuilt modules.
```elixir
defmodule ReverseInteger do
  @min_bound -2_147_483_648
  @max_bound 2_147_483_647

  def reverse(x, acc \\ 0, pos \\ 0)

  def reverse(0, acc, _pos) when acc in @min_bound..@max_bound, do: acc
  def reverse(0, _acc, _pos), do: 0

  @spec reverse(x :: integer, acc :: integer) :: integer
  def reverse(x, acc, pos) do
    acc = acc * 10 + rem(x, 10)
    x = div(x, 10)
    reverse(x, acc, pos + 1)
  end
end
```

```elixir
defmodule ReverseInteger do
  @min_bound -2_147_483_648
  @max_bound 2_147_483_647

  @spec reverse(x :: integer) :: integer
  def reverse(x) do
    x
    |> Integer.digits()
    |> Enum.reverse()
    |> Integer.undigits()
    |> check_bounds()
  end

  def check_bounds(num) do
    if num in @min_bound..@max_bound, do: num, else: 0
  end
end
```