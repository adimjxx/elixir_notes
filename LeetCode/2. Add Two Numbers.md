You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

**Example 1:**
**Input:** l1 = [2,4,3], l2 = [5,6,4]
**Output:** [7,0,8]
**Explanation:** 342 + 465 = 807.

**Example 2:**

**Input:** l1 = [0], l2 = [0]
**Output:** [0]

**Example 3:**

**Input:** l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
**Output:** [8,9,9,9,0,0,0,1]

**Constraints:**

- The number of nodes in each linked list is in the range `[1, 100]`.
- `0 <= Node.val <= 9`
- It is guaranteed that the list represents a number that does not have leading zeros.
# Solution
The logic to this problem, although being straightforward is quite literally a pain to implement. 

This is because you'd need to handle the following edge cases carefully:
- Linked-lists of unequal length
- Carry propagation
- TCO

While TCO avoids stack overflows and is more memory-efficient for deeply recursive calls, **it doesn't automatically mean "faster"** in Elixir.

In the TCO version:
- You accumulate nodes in reverse order (because it's tail-recursive).
- At the end, you call `reverse_ln/2` to fix the order.
- That **extra reversal step** adds linear overhead (O(n)).

In contrast, the non-TCO version:
- Builds the list in correct order directly during the return phase.
- **Avoids the reversal entirely.**

So even though it's not tail-recursive, it **avoids an entire extra traversal of the list**.

# Code
1. Without TCO (Optimal)
```elixir
# Definition for singly-linked list.
#
# defmodule ListNode do
#   @type t :: %__MODULE__{
#           val: integer,
#           next: ListNode.t() | nil
#         }
#   defstruct val: 0, next: nil
# end

defmodule Solution do
  @spec add_two_numbers(l1 :: ListNode.t | nil, l2 :: ListNode.t | nil) :: ListNode.t | nil
  def add_two_numbers(ln1, ln2, carry \\ 0)

  def add_two_numbers(nil, nil, carry) do
    case carry do
      0 -> nil
      _ -> %ListNode{val: carry, next: nil}
    end
  end

  def add_two_numbers(%ListNode{val: v1, next: nx1}, nil, carry) do
    total = v1 + carry
    sum = rem(total, 10)
    carry = div(total, 10)
    %ListNode{val: sum, next: add_two_numbers(nx1, nil, carry)}
  end

  def add_two_numbers(nil, %ListNode{val: v2, next: nx2}, carry) do
    total = v2 + carry
    sum = rem(total, 10)
    carry = div(total, 10)
    %ListNode{val: sum, next: add_two_numbers(nil, nx2, carry)}
  end

  def add_two_numbers(%ListNode{val: v1, next: nx1}, %ListNode{val: v2, next: nx2}, carry) do
    total = v1 + v2 + carry
    sum = rem(total, 10)
    carry = div(total, 10)
    %ListNode{val: sum, next: add_two_numbers(nx1, nx2, carry)}
  end
end
```
2. With TCO
```elixir
# Definition for singly-linked list.
#
# defmodule ListNode do
#   @type t :: %__MODULE__{
#           val: integer,
#           next: ListNode.t() | nil
#         }
#   defstruct val: 0, next: nil
# end

defmodule Solution do
  @spec add_two_numbers(l1 :: ListNode.t | nil, l2 :: ListNode.t | nil) :: ListNode.t | nil
  def add_two_numbers(ln1, ln2, carry \\ 0, acc \\ nil)

  def add_two_numbers(nil, nil, carry, acc) do
    case carry do
      0 -> acc
      _ -> %ListNode{val: carry, next: acc}
    end
    |> reverse_ln()
  end

  def add_two_numbers(%ListNode{val: v1, next: nx1}, nil, carry, acc) do
    total = v1 + carry
    sum = rem(total, 10)
    carry = div(total, 10)
    acc = %ListNode{val: sum, next: acc}
    add_two_numbers(nx1, nil, carry, acc)
  end

  def add_two_numbers(nil, %ListNode{val: v2, next: nx2}, carry, acc) do
    total = v2 + carry
    sum = rem(total, 10)
    carry = div(total, 10)
    acc = %ListNode{val: sum, next: acc}
    add_two_numbers(nil, nx2, carry, acc)
  end

  def add_two_numbers(%ListNode{val: v1, next: nx1}, %ListNode{val: v2, next: nx2}, carry, acc) do
    total = v1 + v2 + carry
    sum = rem(total, 10)
    carry = div(total, 10)
    acc = %ListNode{val: sum, next: acc}
    add_two_numbers(nx1, nx2, carry, acc)
  end

  def reverse_ln(ln, acc \\ nil)

  def reverse_ln(nil, acc), do: acc

  def reverse_ln(%ListNode{val: v, next: nx}, acc) do
    acc = %ListNode{val: v, next: acc}
    reverse_ln(nx, acc)
  end
end
```
# Results
- The following implementation is without tail-call optimization:
![[Pasted image 20250616200100.png]]
- The following implementation follows tail-call optimization design patterns:
![[Pasted image 20250617073737.png]]