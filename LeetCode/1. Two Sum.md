Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.

You can return the answer in any order.

**Example 1:**

**Input:** nums = [2,7,11,15], target = 9
**Output:** [0,1]
**Explanation:** Because nums[0] + nums[1] == 9, we return [0, 1].

**Example 2:**

**Input:** nums = [3,2,4], target = 6
**Output:** [1,2]

**Example 3:**

**Input:** nums = [3,3], target = 6
**Output:** [0,1]

**Constraints:**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **Only one valid answer exists.**

**Follow-up:** Can you come up with an algorithm that is less than `O(n2)` time complexity?

# Solution
A hash-map implementation to track the previous values with their position is an efficient way to solve this problem.
# Algorithm
1. Traverse through the given list.
2. Calculate the complement every iteration.
3. Check if the complement exists in the map, by checking for keys.
4. If the complement is present, return the corresponding value along with the position of the current head.
5. If the complement isn't present, insert it into the map and recurse with tail.
6. If the list is exhausted return an empty list.
# Code (Optimal)
```elixir
defmodule TwoSum do
  @moduledoc """
  LeetCode
  -x-x-
  Problem : 1
  Name    : Two Sum
  Author  : adimjxx

  This module provides an efficient solution to the Two Sum problem using a hash map (map) to store previously seen numbers and their indices.
  """

  def two_sum(nums, target, map \\ %{}, pos \\ 0)

  def two_sum([], _target, _map, _pos), do: []

  @doc """
  Finds two indices in the list `nums` such that the numbers at those indices add up to `target`.

  The function traverses the list once, storing each number and its index in a map.
  For each number, it checks if the complement (target - number) exists in the map.

  ## Parameters

    - `nums`: List of integers.
    - `target`: The target integer sum.
    - `map` (optional): Internal use — map storing seen values and their indices.
    - `pos` (optional): Internal use — current index position.
  """
  @spec two_sum(nums :: [integer()], target :: integer(), map :: map(), pos :: integer()) :: [
          integer()
        ]
  def two_sum([head | tail], target, map, pos) do
    complement = target - head

    case Map.get(map, complement) do
      nil ->
        map = Map.put(map, head, pos)
        two_sum(tail, target, map, pos + 1)

      found_value ->
        [found_value, pos]
    end
  end
end
```
# Results
![[Pasted image 20250615224604.png]]