| S.No.  | Concept               |
| ------ | --------------------- |
| 1.1.   | Hello, World!         |
| 1.2.   | Bindings              |
| 1.3.   | Source File Structure |
| 1.3.1. | Why Namespaces?       |
| 1.3.2. | Named Functions       |
| 1.3.3. | Arity of Functions    |
| 1.3.4. | Naming Conventions    |
| 1.4.   | Standard Library      |
| 1.5.   | Code Comments         |
# 1.1. Hello, World!
Here's a small **"Hello, World!"** program:
```elixir
defmodule HelloWorld do
  @doc """
  Simply returns "Hello, World!"
  """
  @spec hello :: String.t()
  def hello do
    "Hello, World!"
  end
end
```
# 1.2. Bindings
One can use the **match `=` operator** to bind a value of any type to a variable name.
```elixir
# Bound an integer value of 1
count = 1
# You may re-bind variables
count = 2

# You may re-bind any type to a variable
count = false

# Strings can be created by enclosing characters within double quotes
message = "Success!"
```
In functional programming (due to immutability) when the value is re-bound to the same variable, the old value is discarded and the last assigned value is what is stored in the variable.
# 1.3. Source File Structure
Being a functional language, Elixir's source files should contain namespaces called **modules**.
- A **`module`** in Elixir is a **namespace** that groups related functions, types, and macros.
- Unlike Python, the **module name is not tied to the file name**. The file name is just a convention.
- All **named functions** in Elixir `.ex` files **must be defined inside a module**. This rule doesn't apply to `.exs` files.
- The `defmodule` keyword is used to define a module. 
- All modules are available to all other modules at runtime and do not require an _access modifier_ to make them visible to other parts of the program. 
- A _module_ is analogous to a _class_ in other programming languages.

> A **namespace** is a way to group and isolate names (like functions, variables, modules) so they **don’t conflict** with names in other parts of a program. Think of it like a **folder** on your computer; You can have `file.txt` inside `/photos/` and another `file.txt` inside `/documents/` — no problem, because the **paths** are different. Similarly, namespaces allow you to define `hello()` in two different places, like `MyApp.Utils.hello()` and `MyApp.Greeter.hello()` — and both can coexist.

## 1.3.1. Why Namespaces?
If you are coming from languages like Python, you'd rely on the path to understand the hierarchy (its implicit). A **module** in Python is fundamentally tied to a **single `.py` file** and the module name comes from the file name.
```python
# file: my_app/users/controller.py
class Controller:
    ...
```
In Elixir, the **module name is explicitly defined in the code** and isn't automatically derived from the file path. While it’s conventional to mirror the module structure with the file layout (e.g., `MyApp.Users.Controller` lives in `lib/my_app/users/controller.ex`), it's not enforced by the compiler.

This decoupling between module name and file path allows for greater flexibility. For instance, you could define multiple modules in a single file, or split related functionality across multiple files using macros — something not typically possible in Python.
- Modules = explicitly named via `defmodule`
- File structure is **convention**, not requirement
- You reference by **module name**, not file name
## 1.3.2. Named functions
- _Named Functions_ must be defined in a module. The `def` keyword is used to define a _public_ named function.
- Each function can have zero or more arguments. The value of the last expression in a function is always _implicitly returned_.
```elixir
defmodule Calculator do
	def add(x, y) do
		x + y
	end
end
```
- Invoking a function is done by specifying its module and function name and passing arguments for each of the function's arguments.
```elixir
sum = Calculator.add(1, 2)
# => 3
```
- The `defp` keyword can be used instead of `def` to define a _private_ function. Private functions can only be used from within the same module that defined them.
- When invoking a function inside the same module where it's defined, the module name can be omitted.
- You may also write short functions using a one-line syntax (note the comma `,` and the colon `:` around the keyword `do`).
```elixir
defmodule Calculator do
  def subtract(x, y) do
    private_subtract(x, y)
  end

  defp private_subtract(x, y), do: x - y
end

difference = Calculator.subtract(7, 2)
# => 5

difference = Calculator.private_subtract(7, 2)
# => ** (UndefinedFunctionError) function Calculator.private_subtract/2 is undefined or private
#       Calculator.private_subtract(7, 2)
```
## 1.3.3. Arity of functions
It is common to refer to functions with their _arity_. The _arity_ of a function is the number of arguments it accepts.
```elixir
# add/3 because this function has three arguments, thus an arity of 3
def add(x, y, z) do
	x + y + z
end
```
## 1.3.4. Naming conventions
Module names should use `PascalCase`. A module name must start with an uppercase letter `A-Z` and can contain letters `a-zA-Z`, numbers `0-9`, and underscores `_`.

Variable and function names should use `snake_case`. A variable or function name must start with a lowercase letter `a-z` or an underscore `_`, can contain letters `a-zA-Z`, numbers `0-9`, and underscores `_`, and might end with a question mark `?` or an exclamation mark `!`.
# 1.4. Standard library
Elixir has a very rich and well-documented standard library. The documentation is available online at [hexdocs.pm/elixir](https://hexdocs.pm/elixir/Kernel.html#content). Save this link somewhere - you will use it a lot!

Most built-in data types have a corresponding module that offers functions for working with that data type, e.g. there's the `Integer` module for integers, `String` module for strings, `List` module for lists and so on.

A notable module is the `Kernel` module. It provides the basic capabilities on top of which the rest of the standard library is built, like arithmetic operators, control-flow macros, and much more. Functions for the `Kernel` module are automatically imported, so you can use them without the `Kernel.` prefix.
# 1.5. Code comments
Comments can be used to leave notes for other developers reading the source code. Single line comments in Elixir are preceded by `#`.