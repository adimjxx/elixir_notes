Elixir represents true and false values with the `boolean` type. There are only two values: `true` and `false`. These values can be bound to a variable:
```elixir
true_variable = true
false_variable = false
```
The `true` and `false` values in elixir are both `booleans` as well as atoms.
```elixir
iex(1)> is_boolean(true)
true
iex(2)> is_atom(false)
true
iex(3)>
```
# Strict & Lax Booolean Expressions
1. We can evaluate strict `boolean` expressions using the `and/2`, `or/2`, and `not/1` operators.
```elixir
true_variable = true and true
false_variable = true and false

true_variable = false or true
false_variable = false or false

true_variable = not false
false_variable = not true
```
These `boolean` operators are strict about the LHS (infix) & RHS (prefix) types.

2. Lax `boolean` expressions work with `truthy` and `falsy` logic and are evaluated with `&&/2`, `||/2` and `!/1`.
```elixir
iex(1)> 1 && nil
nil
```

```elixir
iex(1)> h Kernel.and

                            defmacro left and right

guard: true

Strictly boolean "and" operator.

If left is false, returns false, otherwise returns right.

Requires only the left operand to be a boolean since it short-circuits. If the
left operand is not a boolean, a BadBooleanError exception is raised.

Allowed in guard tests.

## Examples

    iex> true and false
    false

    iex> true and "yay!"
    "yay!"

    iex> "yay!" and true
    ** (BadBooleanError) expected a boolean on left-side of "and", got: "yay!"

iex(2)> h Kernel.&&

                             defmacro left && right

Boolean "and" operator.

Provides a short-circuit operator that evaluates and returns the second
expression only if the first one evaluates to a truthy value (neither false nor
nil). Returns the first expression otherwise.

Not allowed in guard clauses.

## Examples

    iex> Enum.empty?([]) && Enum.empty?([])
    true

    iex> List.first([]) && true
    nil

    iex> Enum.empty?([]) && List.first([1])
    1

    iex> false && throw(:bad)
    false

Note that, unlike and/2, this operator accepts any expression as the first
argument, not only booleans.
```

Both types of `boolean` operators are *short-circuit* in nature. This means that if the first half of the expression has enough information to determine the outcome, the evaluation will be cut short.
# Naming Convention
>When writing a function that returns a boolean value, it is idiomatic to end the function name with a `?`. The same convention can be used for variables that store boolean values.

```elixir
def either_true?(a?, b?) do
  a? or b?
end
```